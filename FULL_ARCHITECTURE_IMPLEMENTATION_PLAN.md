# –ü–ª–∞–Ω –ø–æ–ª–Ω–æ–π –∏–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ü–∏–∏ –Ω–æ–≤–æ–π –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã –Ω–∞–≤–∏–≥–∞—Ü–∏–∏
## Hydroponics Monitor v3.0 - Screen Manager System

**–î–∞—Ç–∞ –Ω–∞—á–∞–ª–∞:** –ü–æ —Å–æ–≥–ª–∞—Å–æ–≤–∞–Ω–∏—é  
**–î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å:** 3 –Ω–µ–¥–µ–ª–∏ (15 —Ä–∞–±–æ—á–∏—Ö –¥–Ω–µ–π)  
**–°—Ç–∞—Ç—É—Å:** –î–µ—Ç–∞–ª—å–Ω—ã–π –ø–ª–∞–Ω –≥–æ—Ç–æ–≤ –∫ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—é  
**–í–µ—Ä—Å–∏—è:** 1.0

---

## üìã –°–æ–¥–µ—Ä–∂–∞–Ω–∏–µ

1. [–û–±–∑–æ—Ä –ø–ª–∞–Ω–∞](#–æ–±–∑–æ—Ä-–ø–ª–∞–Ω–∞)
2. [–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞](#–ø–æ–¥–≥–æ—Ç–æ–≤–∫–∞)
3. [–ù–µ–¥–µ–ª—è 1: –§—É–Ω–¥–∞–º–µ–Ω—Ç](#–Ω–µ–¥–µ–ª—è-1-—Ñ—É–Ω–¥–∞–º–µ–Ω—Ç)
4. [–ù–µ–¥–µ–ª—è 2: –ú–∏–≥—Ä–∞—Ü–∏—è —ç–∫—Ä–∞–Ω–æ–≤](#–Ω–µ–¥–µ–ª—è-2-–º–∏–≥—Ä–∞—Ü–∏—è-—ç–∫—Ä–∞–Ω–æ–≤)
5. [–ù–µ–¥–µ–ª—è 3: –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ —Ñ–∏–Ω–∞–ª–∏–∑–∞—Ü–∏—è](#–Ω–µ–¥–µ–ª—è-3-—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ-–∏-—Ñ–∏–Ω–∞–ª–∏–∑–∞—Ü–∏—è)
6. [–ö—Ä–∏—Ç–µ—Ä–∏–∏ –ø—Ä–∏–µ–º–∫–∏](#–∫—Ä–∏—Ç–µ—Ä–∏–∏-–ø—Ä–∏–µ–º–∫–∏)
7. [–ü–ª–∞–Ω —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è](#–ø–ª–∞–Ω-—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è)
8. [Rollback —Å—Ç—Ä–∞—Ç–µ–≥–∏—è](#rollback-—Å—Ç—Ä–∞—Ç–µ–≥–∏—è)

---

## üéØ –û–±–∑–æ—Ä –ø–ª–∞–Ω–∞

### –¶–µ–ª–∏

1. ‚úÖ –°–æ–∑–¥–∞—Ç—å –º–æ–¥—É–ª—å–Ω—É—é —Å–∏—Å—Ç–µ–º—É —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —ç–∫—Ä–∞–Ω–∞–º–∏
2. ‚úÖ –ú–∏–≥—Ä–∏—Ä–æ–≤–∞—Ç—å –≤—Å–µ 27 —ç–∫—Ä–∞–Ω–æ–≤ –Ω–∞ –Ω–æ–≤—É—é –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—É
3. ‚úÖ –°–æ–∫—Ä–∞—Ç–∏—Ç—å –∫–æ–¥ –Ω–∞ 50% (—Å 3345 –¥–æ ~1700 —Å—Ç—Ä–æ–∫)
4. ‚úÖ –î–æ—Å—Ç–∏—á—å 80% –ø–æ–∫—Ä—ã—Ç–∏—è —Ç–µ—Å—Ç–∞–º–∏
5. ‚úÖ –£—Å—Ç—Ä–∞–Ω–∏—Ç—å –≤—Å–µ –≥–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ

### –ö–ª—é—á–µ–≤—ã–µ –º–µ—Ç—Ä–∏–∫–∏

| –ú–µ—Ç—Ä–∏–∫–∞ | –¢–µ–∫—É—â–µ–µ | –¶–µ–ª–µ–≤–æ–µ |
|---------|---------|---------|
| –†–∞–∑–º–µ—Ä lvgl_ui.c | 3345 —Å—Ç—Ä–æ–∫ | <1700 —Å—Ç—Ä–æ–∫ |
| –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ | 25+ | 0 |
| –î—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–æ–¥–∞ | 70% | <10% |
| –í—Ä–µ–º—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —ç–∫—Ä–∞–Ω–∞ | 2+ —á–∞—Å–∞ | 30 –º–∏–Ω |
| –ü–æ–∫—Ä—ã—Ç–∏–µ —Ç–µ—Å—Ç–∞–º–∏ | 0% | 80% |

### –ö–æ–º–∞–Ω–¥–∞

- **–†–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫ 1**: Core Manager + Navigation
- **–†–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫ 2**: Widgets + Templates
- **–†–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫ 3**: Screen Migration
- **QA**: –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ (—Å –Ω–µ–¥–µ–ª–∏ 2)

---

## üîß –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ (–î–µ–Ω—å 0)

### –ó–∞–¥–∞—á–∞ 0.1: –°–æ–∑–¥–∞—Ç—å –≤–µ—Ç–∫—É —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏

```bash
git checkout -b feature/screen-manager-full
git push -u origin feature/screen-manager-full
```

**–ö—Ä–∏—Ç–µ—Ä–∏–π –ø—Ä–∏–µ–º–∫–∏:** –í–µ—Ç–∫–∞ —Å–æ–∑–¥–∞–Ω–∞ –∏ –∑–∞–ø—É—à–µ–Ω–∞

### –ó–∞–¥–∞—á–∞ 0.2: –°–æ–∑–¥–∞—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä—É –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–π

```bash
cd components/lvgl_ui/

# –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–µ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏
mkdir -p screen_manager
mkdir -p screens/base
mkdir -p screens/sensor
mkdir -p screens/system
mkdir -p widgets
mkdir -p navigation

# –°–æ–∑–¥–∞–µ–º —Ñ–∞–π–ª—ã –∑–∞–≥–ª—É—à–∫–∏
touch screen_manager/screen_types.h
touch screen_manager/screen_manager.h
touch screen_manager/screen_manager.c
touch screen_manager/screen_registry.c
touch screen_manager/screen_navigator.c
touch screen_manager/screen_lifecycle.c
```

**–ö—Ä–∏—Ç–µ—Ä–∏–π –ø—Ä–∏–µ–º–∫–∏:** –°—Ç—Ä—É–∫—Ç—É—Ä–∞ —Å–æ–∑–¥–∞–Ω–∞, –∫–æ–º–ø–∏–ª–∏—Ä—É–µ—Ç—Å—è –±–µ–∑ –æ—à–∏–±–æ–∫

### –ó–∞–¥–∞—á–∞ 0.3: –û–±–Ω–æ–≤–∏—Ç—å CMakeLists.txt

```cmake
# components/lvgl_ui/CMakeLists.txt

idf_component_register(
    SRCS
        "lvgl_ui.c"
        "ph_screen.c"
        "sensor_screens_optimized.c"
        "ui_manager.c"
        
        # Screen Manager Core
        "screen_manager/screen_manager.c"
        "screen_manager/screen_registry.c"
        "screen_manager/screen_navigator.c"
        "screen_manager/screen_lifecycle.c"
        
        # Base screens
        "screens/base/screen_base.c"
        "screens/base/screen_template.c"
        "screens/base/screen_factory.c"
        
        # Concrete screens
        "screens/main_screen.c"
        "screens/sensor/sensor_detail_screen.c"
        "screens/sensor/sensor_settings_screen.c"
        "screens/system/system_menu_screen.c"
        # ... –¥–æ–±–∞–≤–∏–º –ø–æ –º–µ—Ä–µ —Å–æ–∑–¥–∞–Ω–∏—è
        
        # Widgets
        "widgets/back_button.c"
        "widgets/status_bar.c"
        "widgets/menu_list.c"
        "widgets/sensor_card.c"
        
    INCLUDE_DIRS
        "."
        "screen_manager"
        "screens"
        "screens/base"
        "screens/sensor"
        "screens/system"
        "widgets"
        "navigation"
        
    REQUIRES
        lvgl
        driver
        esp_timer
)
```

**–ö—Ä–∏—Ç–µ—Ä–∏–π –ø—Ä–∏–µ–º–∫–∏:** –ö–æ–º–ø–∏–ª—è—Ü–∏—è –ø—Ä–æ—Ö–æ–¥–∏—Ç –±–µ–∑ –æ—à–∏–±–æ–∫

### –ó–∞–¥–∞—á–∞ 0.4: –°–æ–∑–¥–∞—Ç—å —Ç–µ—Å—Ç–æ–≤–æ–µ –æ–∫—Ä—É–∂–µ–Ω–∏–µ

```bash
mkdir -p test/screen_manager
touch test/screen_manager/test_screen_registry.c
touch test/screen_manager/test_navigator.c
touch test/screen_manager/test_lifecycle.c
```

**–ö—Ä–∏—Ç–µ—Ä–∏–π –ø—Ä–∏–µ–º–∫–∏:** –¢–µ—Å—Ç–æ–≤–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –≥–æ—Ç–æ–≤–∞

---

## üìÖ –ù–µ–¥–µ–ª—è 1: –§—É–Ω–¥–∞–º–µ–Ω—Ç (–î–Ω–∏ 1-5)

### –î–µ–Ω—å 1: –¢–∏–ø—ã –¥–∞–Ω–Ω—ã—Ö –∏ Registry

#### –ó–∞–¥–∞—á–∞ 1.1: –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Ç–∏–ø—ã –¥–∞–Ω–Ω—ã—Ö (4 —á–∞—Å–∞)

**–§–∞–π–ª:** `screen_manager/screen_types.h`

```c
#pragma once

#include "lvgl.h"
#include "esp_err.h"
#include <stdbool.h>
#include <stdint.h>

#ifdef __cplusplus
extern "C" {
#endif

/* =============================
 *  –ö–û–ù–°–¢–ê–ù–¢–´
 * ============================= */
#define MAX_SCREENS         40    // –ú–∞–∫—Å–∏–º—É–º —ç–∫—Ä–∞–Ω–æ–≤
#define MAX_INSTANCES       15    // –ú–∞–∫—Å–∏–º—É–º –∞–∫—Ç–∏–≤–Ω—ã—Ö —ç–∫–∑–µ–º–ø–ª—è—Ä–æ–≤
#define MAX_HISTORY         10    // –ì–ª—É–±–∏–Ω–∞ –∏—Å—Ç–æ—Ä–∏–∏ –Ω–∞–≤–∏–≥–∞—Ü–∏–∏
#define MAX_CHILDREN        8     // –ú–∞–∫—Å–∏–º—É–º –¥–æ—á–µ—Ä–Ω–∏—Ö —ç–∫—Ä–∞–Ω–æ–≤
#define MAX_SCREEN_ID_LEN   32    // –î–ª–∏–Ω–∞ ID —ç–∫—Ä–∞–Ω–∞

/* =============================
 *  –¢–ò–ü–´ –≠–ö–†–ê–ù–û–í
 * ============================= */
typedef enum {
    SCREEN_CATEGORY_MAIN,         // –ì–ª–∞–≤–Ω—ã–π —ç–∫—Ä–∞–Ω
    SCREEN_CATEGORY_DETAIL,       // –î–µ—Ç–∞–ª–∏–∑–∞—Ü–∏—è
    SCREEN_CATEGORY_SETTINGS,     // –ù–∞—Å—Ç—Ä–æ–π–∫–∏
    SCREEN_CATEGORY_MENU,         // –ú–µ–Ω—é
    SCREEN_CATEGORY_FORM,         // –§–æ—Ä–º–∞
    SCREEN_CATEGORY_DIALOG,       // –î–∏–∞–ª–æ–≥
    SCREEN_CATEGORY_INFO,         // –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
} screen_category_t;

/* =============================
 *  CALLBACK –¢–ò–ü–´
 * ============================= */

// –°–æ–∑–¥–∞–Ω–∏–µ —ç–∫—Ä–∞–Ω–∞
typedef lv_obj_t* (*screen_create_fn_t)(void *params);

// –£–Ω–∏—á—Ç–æ–∂–µ–Ω–∏–µ —ç–∫—Ä–∞–Ω–∞
typedef esp_err_t (*screen_destroy_fn_t)(lv_obj_t *screen_obj);

// –ü–æ–∫–∞–∑ —ç–∫—Ä–∞–Ω–∞
typedef esp_err_t (*screen_show_fn_t)(lv_obj_t *screen_obj, void *params);

// –°–∫—Ä—ã—Ç–∏–µ —ç–∫—Ä–∞–Ω–∞
typedef esp_err_t (*screen_hide_fn_t)(lv_obj_t *screen_obj);

// –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
typedef esp_err_t (*screen_update_fn_t)(lv_obj_t *screen_obj, void *data);

// –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –ø–æ–∫–∞–∑–∞
typedef bool (*screen_can_show_fn_t)(void);

/* =============================
 *  –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø –≠–ö–†–ê–ù–ê
 * ============================= */
typedef struct {
    // –ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è
    char id[MAX_SCREEN_ID_LEN];   // –£–Ω–∏–∫–∞–ª—å–Ω—ã–π ID
    const char *title;             // –ó–∞–≥–æ–ª–æ–≤–æ–∫ —ç–∫—Ä–∞–Ω–∞
    screen_category_t category;    // –ö–∞—Ç–µ–≥–æ—Ä–∏—è
    
    // –ù–∞–≤–∏–≥–∞—Ü–∏—è
    char parent_id[MAX_SCREEN_ID_LEN];  // ID —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–æ–≥–æ —ç–∫—Ä–∞–Ω–∞
    bool can_go_back;              // –ú–æ–∂–Ω–æ –ª–∏ –≤–µ—Ä–Ω—É—Ç—å—Å—è –Ω–∞–∑–∞–¥
    bool is_root;                  // –ö–æ—Ä–Ω–µ–≤–æ–π —ç–∫—Ä–∞–Ω (main)
    
    // –ñ–∏–∑–Ω–µ–Ω–Ω—ã–π —Ü–∏–∫–ª
    bool lazy_load;                // –õ–µ–Ω–∏–≤–∞—è –∑–∞–≥—Ä—É–∑–∫–∞
    bool cache_on_hide;            // –ö—ç—à–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–∏ —Å–∫—Ä—ã—Ç–∏–∏
    bool destroy_on_hide;          // –£–Ω–∏—á—Ç–æ–∂–∞—Ç—å –ø—Ä–∏ —Å–∫—Ä—ã—Ç–∏–∏
    uint32_t cache_timeout_ms;     // –¢–∞–π–º–∞—É—Ç –∫—ç—à–∞ (0 = –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ)
    
    // UI
    bool has_status_bar;           // –ï—Å—Ç—å –ª–∏ —Å—Ç–∞—Ç—É—Å-–±–∞—Ä
    bool has_back_button;          // –ï—Å—Ç—å –ª–∏ –∫–Ω–æ–ø–∫–∞ –Ω–∞–∑–∞–¥
    
    // Callbacks
    screen_create_fn_t create_fn;  // –§—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∏—è
    screen_destroy_fn_t destroy_fn; // –§—É–Ω–∫—Ü–∏—è —É–Ω–∏—á—Ç–æ–∂–µ–Ω–∏—è (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
    screen_show_fn_t on_show;      // –ü—Ä–∏ –ø–æ–∫–∞–∑–µ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
    screen_hide_fn_t on_hide;      // –ü—Ä–∏ —Å–∫—Ä—ã—Ç–∏–∏ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
    screen_update_fn_t on_update;  // –ü—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
    screen_can_show_fn_t can_show_fn; // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–µ—Ä–µ–¥ –ø–æ–∫–∞–∑–æ–º (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
    
    // –î–∞–Ω–Ω—ã–µ
    void *user_data;               // –ü—Ä–æ–∏–∑–≤–æ–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
} screen_config_t;

/* =============================
 *  –≠–ö–ó–ï–ú–ü–õ–Ø–† –≠–ö–†–ê–ù–ê
 * ============================= */
typedef struct screen_instance_t {
    // –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
    screen_config_t *config;       // –°—Å—ã–ª–∫–∞ –Ω–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é
    
    // LVGL –æ–±—ä–µ–∫—Ç—ã
    lv_obj_t *screen_obj;          // LVGL —ç–∫—Ä–∞–Ω
    lv_group_t *encoder_group;     // –ì—Ä—É–ø–ø–∞ —ç–Ω–∫–æ–¥–µ—Ä–∞
    
    // –°–æ—Å—Ç–æ—è–Ω–∏–µ
    bool is_created;               // –°–æ–∑–¥–∞–Ω –ª–∏ —ç–∫—Ä–∞–Ω
    bool is_visible;               // –í–∏–¥–∏–º –ª–∏ —ç–∫—Ä–∞–Ω
    bool is_cached;                // –í –∫—ç—à–µ –ª–∏ —ç–∫—Ä–∞–Ω
    
    // –í—Ä–µ–º–µ–Ω–Ω—ã–µ –º–µ—Ç–∫–∏
    uint32_t create_time;          // Timestamp —Å–æ–∑–¥–∞–Ω–∏—è
    uint32_t last_show_time;       // Timestamp –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –ø–æ–∫–∞–∑–∞
    uint32_t cache_time;           // Timestamp –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏—è
    
    // –ù–∞–≤–∏–≥–∞—Ü–∏—è
    struct screen_instance_t *parent;  // –†–æ–¥–∏—Ç–µ–ª—å
    struct screen_instance_t *children[MAX_CHILDREN]; // –î–æ—á–µ—Ä–Ω–∏–µ
    uint8_t children_count;
    
    // –ü–∞—Ä–∞–º–µ—Ç—Ä—ã
    void *show_params;             // –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –ø–æ–∫–∞–∑–∞
} screen_instance_t;

/* =============================
 *  –ú–ï–ù–ï–î–ñ–ï–† –≠–ö–†–ê–ù–û–í
 * ============================= */
typedef struct {
    // –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
    bool enable_cache;             // –í–∫–ª—é—á–∏—Ç—å –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ
    bool enable_history;           // –í–∫–ª—é—á–∏—Ç—å –∏—Å—Ç–æ—Ä–∏—é
    uint8_t max_cache_size;        // –ú–∞–∫—Å–∏–º—É–º —ç–∫—Ä–∞–Ω–æ–≤ –≤ –∫—ç—à–µ
    
    // –ê–Ω–∏–º–∞—Ü–∏–∏
    uint32_t transition_time;      // –í—Ä–µ–º—è –ø–µ—Ä–µ—Ö–æ–¥–∞ (–º—Å)
    bool enable_animations;        // –í–∫–ª—é—á–∏—Ç—å –∞–Ω–∏–º–∞—Ü–∏–∏
} screen_manager_config_t;

typedef struct {
    // –†–µ–µ—Å—Ç—Ä —ç–∫—Ä–∞–Ω–æ–≤
    screen_config_t *screens[MAX_SCREENS];
    uint8_t screen_count;
    
    // –ê–∫—Ç–∏–≤–Ω—ã–µ —ç–∫–∑–µ–º–ø–ª—è—Ä—ã
    screen_instance_t *instances[MAX_INSTANCES];
    uint8_t instance_count;
    
    // –¢–µ–∫—É—â–∏–π —ç–∫—Ä–∞–Ω
    screen_instance_t *current_screen;
    
    // –ò—Å—Ç–æ—Ä–∏—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏
    screen_instance_t *history[MAX_HISTORY];
    uint8_t history_index;
    uint8_t history_count;
    
    // –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
    screen_manager_config_t config;
    
    // –°–æ—Å—Ç–æ—è–Ω–∏–µ
    bool is_initialized;
    
    // –ú—å—é—Ç–µ–∫—Å
    SemaphoreHandle_t mutex;
} screen_manager_t;

#ifdef __cplusplus
}
#endif
```

**–ö—Ä–∏—Ç–µ—Ä–∏–π –ø—Ä–∏–µ–º–∫–∏:** 
- ‚úÖ –í—Å–µ —Ç–∏–ø—ã –æ–ø—Ä–µ–¥–µ–ª–µ–Ω—ã
- ‚úÖ –ö–æ–º–ø–∏–ª–∏—Ä—É–µ—Ç—Å—è –±–µ–∑ –æ—à–∏–±–æ–∫
- ‚úÖ –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ –Ω–∞ –º–µ—Å—Ç–µ

#### –ó–∞–¥–∞—á–∞ 1.2: –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å Registry (4 —á–∞—Å–∞)

**–§–∞–π–ª:** `screen_manager/screen_registry.c`

```c
#include "screen_types.h"
#include "screen_manager.h"
#include "esp_log.h"
#include <string.h>

static const char *TAG = "SCREEN_REGISTRY";

// –ì–ª–æ–±–∞–ª—å–Ω—ã–π –º–µ–Ω–µ–¥–∂–µ—Ä (–µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è –≥–ª–æ–±–∞–ª—å–Ω–∞—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è!)
static screen_manager_t g_manager = {0};

/* =============================
 *  –í–ù–£–¢–†–ï–ù–ù–ò–ï –§–£–ù–ö–¶–ò–ò
 * ============================= */

static screen_config_t* find_screen_by_id(const char *screen_id)
{
    if (!screen_id) return NULL;
    
    for (int i = 0; i < g_manager.screen_count; i++) {
        if (g_manager.screens[i] && 
            strcmp(g_manager.screens[i]->id, screen_id) == 0) {
            return g_manager.screens[i];
        }
    }
    return NULL;
}

static bool is_screen_id_valid(const char *screen_id)
{
    if (!screen_id || strlen(screen_id) == 0) {
        return false;
    }
    if (strlen(screen_id) >= MAX_SCREEN_ID_LEN) {
        return false;
    }
    return true;
}

/* =============================
 *  –ü–£–ë–õ–ò–ß–ù–´–ï –§–£–ù–ö–¶–ò–ò
 * ============================= */

esp_err_t screen_registry_init(void)
{
    if (g_manager.is_initialized) {
        ESP_LOGW(TAG, "Registry already initialized");
        return ESP_OK;
    }
    
    memset(&g_manager, 0, sizeof(screen_manager_t));
    
    // –°–æ–∑–¥–∞–µ–º –º—å—é—Ç–µ–∫—Å
    g_manager.mutex = xSemaphoreCreateMutex();
    if (!g_manager.mutex) {
        ESP_LOGE(TAG, "Failed to create mutex");
        return ESP_ERR_NO_MEM;
    }
    
    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
    g_manager.config.enable_cache = true;
    g_manager.config.enable_history = true;
    g_manager.config.max_cache_size = 5;
    g_manager.config.transition_time = 300;
    g_manager.config.enable_animations = true;
    
    g_manager.is_initialized = true;
    
    ESP_LOGI(TAG, "Registry initialized");
    return ESP_OK;
}

esp_err_t screen_register(const screen_config_t *config)
{
    if (!config) {
        return ESP_ERR_INVALID_ARG;
    }
    
    if (!is_screen_id_valid(config->id)) {
        ESP_LOGE(TAG, "Invalid screen ID");
        return ESP_ERR_INVALID_ARG;
    }
    
    if (!config->create_fn) {
        ESP_LOGE(TAG, "Screen %s: create_fn is required", config->id);
        return ESP_ERR_INVALID_ARG;
    }
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ª–∏–º–∏—Ç
    if (g_manager.screen_count >= MAX_SCREENS) {
        ESP_LOGE(TAG, "Maximum number of screens reached");
        return ESP_ERR_NO_MEM;
    }
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥—É–±–ª–∏–∫–∞—Ç—ã
    if (find_screen_by_id(config->id)) {
        ESP_LOGE(TAG, "Screen %s already registered", config->id);
        return ESP_ERR_INVALID_STATE;
    }
    
    // –ë–ª–æ–∫–∏—Ä—É–µ–º
    if (xSemaphoreTake(g_manager.mutex, pdMS_TO_TICKS(1000)) != pdTRUE) {
        return ESP_ERR_TIMEOUT;
    }
    
    // –ö–æ–ø–∏—Ä—É–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é
    screen_config_t *new_config = malloc(sizeof(screen_config_t));
    if (!new_config) {
        xSemaphoreGive(g_manager.mutex);
        return ESP_ERR_NO_MEM;
    }
    memcpy(new_config, config, sizeof(screen_config_t));
    
    // –î–æ–±–∞–≤–ª—è–µ–º –≤ —Ä–µ–µ—Å—Ç—Ä
    g_manager.screens[g_manager.screen_count] = new_config;
    g_manager.screen_count++;
    
    xSemaphoreGive(g_manager.mutex);
    
    ESP_LOGI(TAG, "Registered screen '%s' (category: %d)", 
             config->id, config->category);
    return ESP_OK;
}

esp_err_t screen_unregister(const char *screen_id)
{
    if (!is_screen_id_valid(screen_id)) {
        return ESP_ERR_INVALID_ARG;
    }
    
    // –ë–ª–æ–∫–∏—Ä—É–µ–º
    if (xSemaphoreTake(g_manager.mutex, pdMS_TO_TICKS(1000)) != pdTRUE) {
        return ESP_ERR_TIMEOUT;
    }
    
    // –ò—â–µ–º —ç–∫—Ä–∞–Ω
    int index = -1;
    for (int i = 0; i < g_manager.screen_count; i++) {
        if (g_manager.screens[i] && 
            strcmp(g_manager.screens[i]->id, screen_id) == 0) {
            index = i;
            break;
        }
    }
    
    if (index == -1) {
        xSemaphoreGive(g_manager.mutex);
        return ESP_ERR_NOT_FOUND;
    }
    
    // –û—Å–≤–æ–±–æ–∂–¥–∞–µ–º –ø–∞–º—è—Ç—å
    free(g_manager.screens[index]);
    
    // –°–¥–≤–∏–≥–∞–µ–º –º–∞—Å—Å–∏–≤
    for (int i = index; i < g_manager.screen_count - 1; i++) {
        g_manager.screens[i] = g_manager.screens[i + 1];
    }
    g_manager.screen_count--;
    g_manager.screens[g_manager.screen_count] = NULL;
    
    xSemaphoreGive(g_manager.mutex);
    
    ESP_LOGI(TAG, "Unregistered screen '%s'", screen_id);
    return ESP_OK;
}

screen_config_t* screen_get_config(const char *screen_id)
{
    if (!is_screen_id_valid(screen_id)) {
        return NULL;
    }
    
    return find_screen_by_id(screen_id);
}

uint8_t screen_get_registered_count(void)
{
    return g_manager.screen_count;
}

screen_manager_t* screen_manager_get_instance(void)
{
    return &g_manager;
}
```

**–§–∞–π–ª:** `screen_manager/screen_registry.h`

```c
#pragma once

#include "screen_types.h"

#ifdef __cplusplus
extern "C" {
#endif

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ä–µ–µ—Å—Ç—Ä–∞
esp_err_t screen_registry_init(void);

// –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è —ç–∫—Ä–∞–Ω–∞
esp_err_t screen_register(const screen_config_t *config);

// –û—Ç–º–µ–Ω–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏
esp_err_t screen_unregister(const char *screen_id);

// –ü–æ–ª—É—á–∏—Ç—å –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é —ç–∫—Ä–∞–Ω–∞
screen_config_t* screen_get_config(const char *screen_id);

// –ü–æ–ª—É—á–∏—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —ç–∫—Ä–∞–Ω–æ–≤
uint8_t screen_get_registered_count(void);

// –ü–æ–ª—É—á–∏—Ç—å —ç–∫–∑–µ–º–ø–ª—è—Ä –º–µ–Ω–µ–¥–∂–µ—Ä–∞ (–¥–ª—è –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è)
screen_manager_t* screen_manager_get_instance(void);

#ifdef __cplusplus
}
#endif
```

**–ö—Ä–∏—Ç–µ—Ä–∏–π –ø—Ä–∏–µ–º–∫–∏:**
- ‚úÖ Registry —Ä–∞–±–æ—Ç–∞–µ—Ç
- ‚úÖ –ú–æ–∂–Ω–æ —Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å/—É–¥–∞–ª—è—Ç—å —ç–∫—Ä–∞–Ω—ã
- ‚úÖ –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥—É–±–ª–∏–∫–∞—Ç–æ–≤ —Ä–∞–±–æ—Ç–∞–µ—Ç
- ‚úÖ Thread-safe (–º—å—é—Ç–µ–∫—Å—ã)

#### –ó–∞–¥–∞—á–∞ 1.3: –Æ–Ω–∏—Ç-—Ç–µ—Å—Ç—ã Registry (2 —á–∞—Å–∞)

**–§–∞–π–ª:** `test/screen_manager/test_screen_registry.c`

```c
#include "unity.h"
#include "screen_registry.h"
#include "screen_types.h"

static lv_obj_t* dummy_create(void *params) {
    return (lv_obj_t*)0xDEADBEEF; // Mock
}

void test_registry_init(void)
{
    esp_err_t ret = screen_registry_init();
    TEST_ASSERT_EQUAL(ESP_OK, ret);
}

void test_screen_register_valid(void)
{
    screen_config_t config = {
        .id = "test_screen",
        .title = "Test Screen",
        .category = SCREEN_CATEGORY_MAIN,
        .create_fn = dummy_create,
    };
    
    esp_err_t ret = screen_register(&config);
    TEST_ASSERT_EQUAL(ESP_OK, ret);
    TEST_ASSERT_EQUAL(1, screen_get_registered_count());
}

void test_screen_register_duplicate(void)
{
    screen_config_t config = {
        .id = "test_screen",
        .title = "Test Screen",
        .category = SCREEN_CATEGORY_MAIN,
        .create_fn = dummy_create,
    };
    
    screen_register(&config);
    esp_err_t ret = screen_register(&config); // –î—É–±–ª–∏–∫–∞—Ç
    TEST_ASSERT_EQUAL(ESP_ERR_INVALID_STATE, ret);
}

void test_screen_get_config(void)
{
    screen_config_t *cfg = screen_get_config("test_screen");
    TEST_ASSERT_NOT_NULL(cfg);
    TEST_ASSERT_EQUAL_STRING("test_screen", cfg->id);
}

void test_screen_unregister(void)
{
    esp_err_t ret = screen_unregister("test_screen");
    TEST_ASSERT_EQUAL(ESP_OK, ret);
    TEST_ASSERT_EQUAL(0, screen_get_registered_count());
}

void setUp(void) {
    screen_registry_init();
}

void tearDown(void) {
    // –û—á–∏—Å—Ç–∫–∞
}

int main(void) {
    UNITY_BEGIN();
    RUN_TEST(test_registry_init);
    RUN_TEST(test_screen_register_valid);
    RUN_TEST(test_screen_register_duplicate);
    RUN_TEST(test_screen_get_config);
    RUN_TEST(test_screen_unregister);
    return UNITY_END();
}
```

**–ö—Ä–∏—Ç–µ—Ä–∏–π –ø—Ä–∏–µ–º–∫–∏:**
- ‚úÖ –í—Å–µ —Ç–µ—Å—Ç—ã –ø—Ä–æ—Ö–æ–¥—è—Ç
- ‚úÖ –ü–æ–∫—Ä—ã—Ç–∏–µ >80%

---

### –î–µ–Ω—å 2: Lifecycle Manager

#### –ó–∞–¥–∞—á–∞ 2.1: –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å Lifecycle (6 —á–∞—Å–æ–≤)

**–§–∞–π–ª:** `screen_manager/screen_lifecycle.c`

```c
#include "screen_lifecycle.h"
#include "screen_registry.h"
#include "esp_log.h"
#include "esp_timer.h"
#include <string.h>

static const char *TAG = "SCREEN_LIFECYCLE";

/* =============================
 *  –í–ù–£–¢–†–ï–ù–ù–ò–ï –§–£–ù–ö–¶–ò–ò
 * ============================= */

static screen_instance_t* find_instance_by_id(const char *screen_id)
{
    screen_manager_t *manager = screen_manager_get_instance();
    
    for (int i = 0; i < manager->instance_count; i++) {
        if (manager->instances[i] && 
            manager->instances[i]->config &&
            strcmp(manager->instances[i]->config->id, screen_id) == 0) {
            return manager->instances[i];
        }
    }
    return NULL;
}

static uint32_t get_time_ms(void)
{
    return (uint32_t)(esp_timer_get_time() / 1000);
}

/* =============================
 *  –°–û–ó–î–ê–ù–ò–ï/–£–ù–ò–ß–¢–û–ñ–ï–ù–ò–ï
 * ============================= */

esp_err_t screen_create_instance(const char *screen_id)
{
    screen_manager_t *manager = screen_manager_get_instance();
    
    if (!screen_id) {
        return ESP_ERR_INVALID_ARG;
    }
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —Å–æ–∑–¥–∞–Ω –ª–∏ —É–∂–µ
    if (find_instance_by_id(screen_id)) {
        ESP_LOGW(TAG, "Screen '%s' already created", screen_id);
        return ESP_OK;
    }
    
    // –ü–æ–ª—É—á–∞–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é
    screen_config_t *config = screen_get_config(screen_id);
    if (!config) {
        ESP_LOGE(TAG, "Screen '%s' not registered", screen_id);
        return ESP_ERR_NOT_FOUND;
    }
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ª–∏–º–∏—Ç
    if (manager->instance_count >= MAX_INSTANCES) {
        ESP_LOGE(TAG, "Maximum instances reached");
        return ESP_ERR_NO_MEM;
    }
    
    // –°–æ–∑–¥–∞–µ–º —ç–∫–∑–µ–º–ø–ª—è—Ä
    screen_instance_t *instance = calloc(1, sizeof(screen_instance_t));
    if (!instance) {
        return ESP_ERR_NO_MEM;
    }
    
    instance->config = config;
    instance->create_time = get_time_ms();
    
    // –í—ã–∑—ã–≤–∞–µ–º —Ñ—É–Ω–∫—Ü–∏—é —Å–æ–∑–¥–∞–Ω–∏—è UI
    instance->screen_obj = config->create_fn(config->user_data);
    if (!instance->screen_obj) {
        ESP_LOGE(TAG, "Failed to create screen '%s'", screen_id);
        free(instance);
        return ESP_FAIL;
    }
    
    // –°–æ–∑–¥–∞–µ–º –≥—Ä—É–ø–ø—É —ç–Ω–∫–æ–¥–µ—Ä–∞
    instance->encoder_group = lv_group_create();
    if (!instance->encoder_group) {
        ESP_LOGW(TAG, "Failed to create encoder group for '%s'", screen_id);
    } else {
        lv_group_set_wrap(instance->encoder_group, true);
    }
    
    instance->is_created = true;
    
    // –î–æ–±–∞–≤–ª—è–µ–º –≤ —Å–ø–∏—Å–æ–∫
    manager->instances[manager->instance_count] = instance;
    manager->instance_count++;
    
    ESP_LOGI(TAG, "Created screen '%s' (%d/%d instances)", 
             screen_id, manager->instance_count, MAX_INSTANCES);
    
    return ESP_OK;
}

esp_err_t screen_destroy_instance(const char *screen_id)
{
    screen_manager_t *manager = screen_manager_get_instance();
    
    if (!screen_id) {
        return ESP_ERR_INVALID_ARG;
    }
    
    // –ò—â–µ–º —ç–∫–∑–µ–º–ø–ª—è—Ä
    int index = -1;
    screen_instance_t *instance = NULL;
    
    for (int i = 0; i < manager->instance_count; i++) {
        if (manager->instances[i] && 
            manager->instances[i]->config &&
            strcmp(manager->instances[i]->config->id, screen_id) == 0) {
            index = i;
            instance = manager->instances[i];
            break;
        }
    }
    
    if (!instance) {
        ESP_LOGW(TAG, "Screen '%s' not found", screen_id);
        return ESP_ERR_NOT_FOUND;
    }
    
    // –ù–µ–ª—å–∑—è —É–Ω–∏—á—Ç–æ–∂–∏—Ç—å —Ç–µ–∫—É—â–∏–π —ç–∫—Ä–∞–Ω
    if (instance == manager->current_screen) {
        ESP_LOGE(TAG, "Cannot destroy current screen '%s'", screen_id);
        return ESP_ERR_INVALID_STATE;
    }
    
    // –í—ã–∑—ã–≤–∞–µ–º custom destroy –µ—Å–ª–∏ –µ—Å—Ç—å
    if (instance->config->destroy_fn) {
        instance->config->destroy_fn(instance->screen_obj);
    }
    
    // –£–Ω–∏—á—Ç–æ–∂–∞–µ–º LVGL –æ–±—ä–µ–∫—Ç—ã
    if (instance->encoder_group) {
        lv_group_del(instance->encoder_group);
    }
    
    if (instance->screen_obj) {
        lv_obj_del(instance->screen_obj);
    }
    
    // –û—Å–≤–æ–±–æ–∂–¥–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
    if (instance->show_params) {
        free(instance->show_params);
    }
    
    // –û—Å–≤–æ–±–æ–∂–¥–∞–µ–º —ç–∫–∑–µ–º–ø–ª—è—Ä
    free(instance);
    
    // –°–¥–≤–∏–≥–∞–µ–º –º–∞—Å—Å–∏–≤
    for (int i = index; i < manager->instance_count - 1; i++) {
        manager->instances[i] = manager->instances[i + 1];
    }
    manager->instance_count--;
    manager->instances[manager->instance_count] = NULL;
    
    ESP_LOGI(TAG, "Destroyed screen '%s' (%d instances left)", 
             screen_id, manager->instance_count);
    
    return ESP_OK;
}

/* =============================
 *  –ü–û–ö–ê–ó/–°–ö–†–´–¢–ò–ï
 * ============================= */

esp_err_t screen_show_instance(const char *screen_id, void *params)
{
    screen_manager_t *manager = screen_manager_get_instance();
    
    screen_instance_t *instance = find_instance_by_id(screen_id);
    if (!instance) {
        // –°–æ–∑–¥–∞–µ–º –µ—Å–ª–∏ lazy_load
        screen_config_t *config = screen_get_config(screen_id);
        if (config && config->lazy_load) {
            esp_err_t ret = screen_create_instance(screen_id);
            if (ret != ESP_OK) {
                return ret;
            }
            instance = find_instance_by_id(screen_id);
        }
        
        if (!instance) {
            ESP_LOGE(TAG, "Screen '%s' not found", screen_id);
            return ESP_ERR_NOT_FOUND;
        }
    }
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ can_show
    if (instance->config->can_show_fn && 
        !instance->config->can_show_fn()) {
        ESP_LOGW(TAG, "Screen '%s' cannot be shown (permission denied)", screen_id);
        return ESP_ERR_NOT_ALLOWED;
    }
    
    // –°–∫—Ä—ã–≤–∞–µ–º —Ç–µ–∫—É—â–∏–π —ç–∫—Ä–∞–Ω
    if (manager->current_screen && 
        manager->current_screen != instance) {
        screen_hide_instance(manager->current_screen->config->id);
    }
    
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
    if (params) {
        if (instance->show_params) {
            free(instance->show_params);
        }
        // –ü—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º, —á—Ç–æ params - —ç—Ç–æ —É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä—É
        // –í —Ä–µ–∞–ª—å–Ω–æ—Å—Ç–∏ –Ω—É–∂–Ω–æ –∑–Ω–∞—Ç—å —Ä–∞–∑–º–µ—Ä
        instance->show_params = params;
    }
    
    // –í—ã–∑—ã–≤–∞–µ–º on_show callback
    if (instance->config->on_show) {
        instance->config->on_show(instance->screen_obj, params);
    }
    
    // –ó–∞–≥—Ä—É–∂–∞–µ–º —ç–∫—Ä–∞–Ω
    lv_scr_load_anim(instance->screen_obj, LV_SCR_LOAD_ANIM_MOVE_LEFT, 
                     manager->config.transition_time, 0, false);
    
    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≥—Ä—É–ø–ø—É —ç–Ω–∫–æ–¥–µ—Ä–∞
    if (instance->encoder_group) {
        lv_indev_t *indev = lv_indev_get_next(NULL);
        while (indev) {
            if (lv_indev_get_type(indev) == LV_INDEV_TYPE_ENCODER) {
                lv_indev_set_group(indev, instance->encoder_group);
                // –§–æ–∫—É—Å –Ω–∞ –ø–µ—Ä–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç
                if (lv_group_get_obj_count(instance->encoder_group) > 0) {
                    lv_group_focus_next(instance->encoder_group);
                }
                break;
            }
            indev = lv_indev_get_next(indev);
        }
    }
    
    instance->is_visible = true;
    instance->last_show_time = get_time_ms();
    manager->current_screen = instance;
    
    ESP_LOGI(TAG, "Showing screen '%s'", screen_id);
    
    return ESP_OK;
}

esp_err_t screen_hide_instance(const char *screen_id)
{
    screen_instance_t *instance = find_instance_by_id(screen_id);
    if (!instance) {
        return ESP_ERR_NOT_FOUND;
    }
    
    if (!instance->is_visible) {
        return ESP_OK; // –£–∂–µ —Å–∫—Ä—ã—Ç
    }
    
    // –í—ã–∑—ã–≤–∞–µ–º on_hide callback
    if (instance->config->on_hide) {
        instance->config->on_hide(instance->screen_obj);
    }
    
    instance->is_visible = false;
    
    // –£–Ω–∏—á—Ç–æ–∂–∞–µ–º –∏–ª–∏ –∫—ç—à–∏—Ä—É–µ–º
    if (instance->config->destroy_on_hide) {
        ESP_LOGI(TAG, "Destroying screen '%s' (destroy_on_hide)", screen_id);
        return screen_destroy_instance(screen_id);
    } else if (instance->config->cache_on_hide) {
        instance->is_cached = true;
        instance->cache_time = get_time_ms();
        ESP_LOGI(TAG, "Caching screen '%s'", screen_id);
    }
    
    ESP_LOGI(TAG, "Hidden screen '%s'", screen_id);
    
    return ESP_OK;
}

/* =============================
 *  –û–ë–ù–û–í–õ–ï–ù–ò–ï
 * ============================= */

esp_err_t screen_update_instance(const char *screen_id, void *data)
{
    screen_instance_t *instance = find_instance_by_id(screen_id);
    if (!instance) {
        return ESP_ERR_NOT_FOUND;
    }
    
    if (!instance->config->on_update) {
        return ESP_ERR_NOT_SUPPORTED;
    }
    
    return instance->config->on_update(instance->screen_obj, data);
}

/* =============================
 *  –ì–ï–¢–¢–ï–†–´
 * ============================= */

screen_instance_t* screen_get_current_instance(void)
{
    screen_manager_t *manager = screen_manager_get_instance();
    return manager->current_screen;
}

screen_instance_t* screen_get_instance_by_id(const char *screen_id)
{
    return find_instance_by_id(screen_id);
}

bool screen_is_visible(const char *screen_id)
{
    screen_instance_t *instance = find_instance_by_id(screen_id);
    return instance ? instance->is_visible : false;
}

uint8_t screen_get_instance_count(void)
{
    screen_manager_t *manager = screen_manager_get_instance();
    return manager->instance_count;
}
```

**–§–∞–π–ª:** `screen_manager/screen_lifecycle.h`

```c
#pragma once

#include "screen_types.h"

#ifdef __cplusplus
extern "C" {
#endif

// –°–æ–∑–¥–∞–Ω–∏–µ —ç–∫–∑–µ–º–ø–ª—è—Ä–∞ —ç–∫—Ä–∞–Ω–∞
esp_err_t screen_create_instance(const char *screen_id);

// –£–Ω–∏—á—Ç–æ–∂–µ–Ω–∏–µ —ç–∫–∑–µ–º–ø–ª—è—Ä–∞
esp_err_t screen_destroy_instance(const char *screen_id);

// –ü–æ–∫–∞–∑ —ç–∫—Ä–∞–Ω–∞
esp_err_t screen_show_instance(const char *screen_id, void *params);

// –°–∫—Ä—ã—Ç–∏–µ —ç–∫—Ä–∞–Ω–∞
esp_err_t screen_hide_instance(const char *screen_id);

// –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö —ç–∫—Ä–∞–Ω–∞
esp_err_t screen_update_instance(const char *screen_id, void *data);

// –ü–æ–ª—É—á–∏—Ç—å —Ç–µ–∫—É—â–∏–π —ç–∫–∑–µ–º–ø–ª—è—Ä
screen_instance_t* screen_get_current_instance(void);

// –ü–æ–ª—É—á–∏—Ç—å —ç–∫–∑–µ–º–ø–ª—è—Ä –ø–æ ID
screen_instance_t* screen_get_instance_by_id(const char *screen_id);

// –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç—å
bool screen_is_visible(const char *screen_id);

// –ü–æ–ª—É—á–∏—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —ç–∫–∑–µ–º–ø–ª—è—Ä–æ–≤
uint8_t screen_get_instance_count(void);

#ifdef __cplusplus
}
#endif
```

**–ö—Ä–∏—Ç–µ—Ä–∏–π –ø—Ä–∏–µ–º–∫–∏:**
- ‚úÖ Lifecycle —Ä–∞–±–æ—Ç–∞–µ—Ç
- ‚úÖ –õ–µ–Ω–∏–≤–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ —Ä–∞–±–æ—Ç–∞–µ—Ç
- ‚úÖ –ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–∞–±–æ—Ç–∞–µ—Ç
- ‚úÖ destroy_on_hide —Ä–∞–±–æ—Ç–∞–µ—Ç

#### –ó–∞–¥–∞—á–∞ 2.2: –Æ–Ω–∏—Ç-—Ç–µ—Å—Ç—ã Lifecycle (2 —á–∞—Å–∞)

**–ö—Ä–∏—Ç–µ—Ä–∏–π –ø—Ä–∏–µ–º–∫–∏:** –¢–µ—Å—Ç—ã –ø–æ–∫—Ä—ã–≤–∞—é—Ç –≤—Å–µ —Ñ—É–Ω–∫—Ü–∏–∏

---

### –î–µ–Ω—å 3: Navigator

#### –ó–∞–¥–∞—á–∞ 3.1: –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å Navigator (6 —á–∞—Å–æ–≤)

**–§–∞–π–ª:** `screen_manager/screen_navigator.c`

```c
#include "screen_navigator.h"
#include "screen_lifecycle.h"
#include "screen_registry.h"
#include "esp_log.h"
#include <string.h>

static const char *TAG = "NAVIGATOR";

/* =============================
 *  –ò–°–¢–û–†–ò–Ø –ù–ê–í–ò–ì–ê–¶–ò–ò
 * ============================= */

static esp_err_t push_history(screen_instance_t *instance)
{
    screen_manager_t *manager = screen_manager_get_instance();
    
    if (!manager->config.enable_history) {
        return ESP_OK;
    }
    
    if (manager->history_count >= MAX_HISTORY) {
        // –°–¥–≤–∏–≥–∞–µ–º –∏—Å—Ç–æ—Ä–∏—é
        for (int i = 0; i < MAX_HISTORY - 1; i++) {
            manager->history[i] = manager->history[i + 1];
        }
        manager->history_count = MAX_HISTORY - 1;
    }
    
    manager->history[manager->history_count] = instance;
    manager->history_count++;
    manager->history_index = manager->history_count - 1;
    
    ESP_LOGD(TAG, "Pushed to history: '%s' (count: %d)", 
             instance->config->id, manager->history_count);
    
    return ESP_OK;
}

static screen_instance_t* pop_history(void)
{
    screen_manager_t *manager = screen_manager_get_instance();
    
    if (manager->history_count == 0) {
        return NULL;
    }
    
    manager->history_count--;
    screen_instance_t *instance = manager->history[manager->history_count];
    manager->history[manager->history_count] = NULL;
    
    if (manager->history_count > 0) {
        manager->history_index = manager->history_count - 1;
    } else {
        manager->history_index = 0;
    }
    
    ESP_LOGD(TAG, "Popped from history: '%s' (count: %d)", 
             instance->config->id, manager->history_count);
    
    return instance;
}

/* =============================
 *  –ù–ê–í–ò–ì–ê–¶–ò–Ø
 * ============================= */

esp_err_t navigator_show(const char *screen_id, void *params)
{
    if (!screen_id) {
        return ESP_ERR_INVALID_ARG;
    }
    
    screen_manager_t *manager = screen_manager_get_instance();
    
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—É—â–∏–π –≤ –∏—Å—Ç–æ—Ä–∏—é
    if (manager->current_screen) {
        push_history(manager->current_screen);
    }
    
    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –Ω–æ–≤—ã–π —ç–∫—Ä–∞–Ω
    esp_err_t ret = screen_show_instance(screen_id, params);
    if (ret != ESP_OK) {
        // –û—Ç–∫–∞—Ç—ã–≤–∞–µ–º –∏—Å—Ç–æ—Ä–∏—é
        pop_history();
        return ret;
    }
    
    return ESP_OK;
}

esp_err_t navigator_go_back(void)
{
    screen_manager_t *manager = screen_manager_get_instance();
    
    if (manager->history_count == 0) {
        ESP_LOGW(TAG, "History is empty, cannot go back");
        return ESP_ERR_INVALID_STATE;
    }
    
    // –ë–µ—Ä–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–π —ç–∫—Ä–∞–Ω –∏–∑ –∏—Å—Ç–æ—Ä–∏–∏
    screen_instance_t *prev = pop_history();
    if (!prev) {
        return ESP_ERR_INVALID_STATE;
    }
    
    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –µ–≥–æ (–±–µ–∑ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –≤ –∏—Å—Ç–æ—Ä–∏—é)
    esp_err_t ret = screen_show_instance(prev->config->id, prev->show_params);
    if (ret != ESP_OK) {
        // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∏—Å—Ç–æ—Ä–∏—é
        push_history(prev);
        return ret;
    }
    
    ESP_LOGI(TAG, "Navigated back to '%s'", prev->config->id);
    
    return ESP_OK;
}

esp_err_t navigator_go_to_parent(void)
{
    screen_manager_t *manager = screen_manager_get_instance();
    
    if (!manager->current_screen) {
        return ESP_ERR_INVALID_STATE;
    }
    
    screen_config_t *config = manager->current_screen->config;
    
    if (!config->can_go_back || strlen(config->parent_id) == 0) {
        ESP_LOGW(TAG, "Screen '%s' has no parent", config->id);
        return ESP_ERR_NOT_SUPPORTED;
    }
    
    // –ò–¥–µ–º –∫ —Ä–æ–¥–∏—Ç–µ–ª—é
    return navigator_show(config->parent_id, NULL);
}

esp_err_t navigator_go_home(void)
{
    screen_manager_t *manager = screen_manager_get_instance();
    
    // –ò—â–µ–º –∫–æ—Ä–Ω–µ–≤–æ–π —ç–∫—Ä–∞–Ω
    for (int i = 0; i < manager->screen_count; i++) {
        screen_config_t *config = manager->screens[i];
        if (config && config->is_root) {
            // –û—á–∏—â–∞–µ–º –∏—Å—Ç–æ—Ä–∏—é
            manager->history_count = 0;
            manager->history_index = 0;
            
            return screen_show_instance(config->id, NULL);
        }
    }
    
    ESP_LOGE(TAG, "Root screen not found");
    return ESP_ERR_NOT_FOUND;
}

/* =============================
 *  –£–¢–ò–õ–ò–¢–´
 * ============================= */

uint8_t navigator_get_history_count(void)
{
    screen_manager_t *manager = screen_manager_get_instance();
    return manager->history_count;
}

void navigator_clear_history(void)
{
    screen_manager_t *manager = screen_manager_get_instance();
    manager->history_count = 0;
    manager->history_index = 0;
    memset(manager->history, 0, sizeof(manager->history));
    ESP_LOGI(TAG, "History cleared");
}
```

**–§–∞–π–ª:** `screen_manager/screen_navigator.h`

```c
#pragma once

#include "screen_types.h"

#ifdef __cplusplus
extern "C" {
#endif

// –ü–æ–∫–∞–∑–∞—Ç—å —ç–∫—Ä–∞–Ω (—Å –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ–º –≤ –∏—Å—Ç–æ—Ä–∏—é)
esp_err_t navigator_show(const char *screen_id, void *params);

// –í–µ—Ä–Ω—É—Ç—å—Å—è –Ω–∞–∑–∞–¥ (–∏–∑ –∏—Å—Ç–æ—Ä–∏–∏)
esp_err_t navigator_go_back(void);

// –ü–µ—Ä–µ–π—Ç–∏ –∫ —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–æ–º—É —ç–∫—Ä–∞–Ω—É
esp_err_t navigator_go_to_parent(void);

// –ü–µ—Ä–µ–π—Ç–∏ –∫ –∫–æ—Ä–Ω–µ–≤–æ–º—É —ç–∫—Ä–∞–Ω—É (–æ—á–∏—Å—Ç–∫–∞ –∏—Å—Ç–æ—Ä–∏–∏)
esp_err_t navigator_go_home(void);

// –ü–æ–ª—É—á–∏—Ç—å —Ä–∞–∑–º–µ—Ä –∏—Å—Ç–æ—Ä–∏–∏
uint8_t navigator_get_history_count(void);

// –û—á–∏—Å—Ç–∏—Ç—å –∏—Å—Ç–æ—Ä–∏—é
void navigator_clear_history(void);

#ifdef __cplusplus
}
#endif
```

**–ö—Ä–∏—Ç–µ—Ä–∏–π –ø—Ä–∏–µ–º–∫–∏:**
- ‚úÖ –ù–∞–≤–∏–≥–∞—Ü–∏—è –≤–ø–µ—Ä–µ–¥ —Ä–∞–±–æ—Ç–∞–µ—Ç
- ‚úÖ –ù–∞–≤–∏–≥–∞—Ü–∏—è –Ω–∞–∑–∞–¥ —Ä–∞–±–æ—Ç–∞–µ—Ç
- ‚úÖ –ò—Å—Ç–æ—Ä–∏—è —Ä–∞–±–æ—Ç–∞–µ—Ç
- ‚úÖ go_to_parent –Ω–∞—Ö–æ–¥–∏—Ç —Ä–æ–¥–∏—Ç–µ–ª—è

#### –ó–∞–¥–∞—á–∞ 3.2: –Æ–Ω–∏—Ç-—Ç–µ—Å—Ç—ã Navigator (2 —á–∞—Å–∞)

---

### –î–µ–Ω—å 4: Screen Manager API

#### –ó–∞–¥–∞—á–∞ 4.1: –ì–ª–∞–≤–Ω—ã–π API (4 —á–∞—Å–∞)

**–§–∞–π–ª:** `screen_manager/screen_manager.h`

```c
#pragma once

#include "screen_types.h"
#include "screen_registry.h"
#include "screen_lifecycle.h"
#include "screen_navigator.h"

#ifdef __cplusplus
extern "C" {
#endif

/* =============================
 *  –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø
 * ============================= */

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Screen Manager
esp_err_t screen_manager_init(const screen_manager_config_t *config);

// –î–µ–∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
esp_err_t screen_manager_deinit(void);

/* =============================
 *  –ù–ê–í–ò–ì–ê–¶–ò–Ø (–£–ø—Ä–æ—â–µ–Ω–Ω—ã–π API)
 * ============================= */

// –ü–æ–∫–∞–∑–∞—Ç—å —ç–∫—Ä–∞–Ω
esp_err_t screen_show(const char *screen_id, void *params);

// –°–∫—Ä—ã—Ç—å —ç–∫—Ä–∞–Ω
esp_err_t screen_hide(const char *screen_id);

// –í–µ—Ä–Ω—É—Ç—å—Å—è –Ω–∞–∑–∞–¥
esp_err_t screen_go_back(void);

// –ö —Ä–æ–¥–∏—Ç–µ–ª—é
esp_err_t screen_go_to_parent(void);

// –ù–∞ –≥–ª–∞–≤–Ω—ã–π
esp_err_t screen_go_home(void);

// –û–±–Ω–æ–≤–∏—Ç—å –¥–∞–Ω–Ω—ã–µ
esp_err_t screen_update(const char *screen_id, void *data);

/* =============================
 *  –£–ü–†–ê–í–õ–ï–ù–ò–ï
 * ============================= */

// –°–æ–∑–¥–∞—Ç—å —ç–∫—Ä–∞–Ω –≤—Ä—É—á–Ω—É—é
esp_err_t screen_create(const char *screen_id);

// –£–Ω–∏—á—Ç–æ–∂–∏—Ç—å —ç–∫—Ä–∞–Ω
esp_err_t screen_destroy(const char *screen_id);

// –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—å —ç–∫—Ä–∞–Ω
esp_err_t screen_reload(const char *screen_id);

/* =============================
 *  –ì–ï–¢–¢–ï–†–´
 * ============================= */

// –ü–æ–ª—É—á–∏—Ç—å —Ç–µ–∫—É—â–∏–π —ç–∫—Ä–∞–Ω
screen_instance_t* screen_get_current(void);

// –ü–æ–ª—É—á–∏—Ç—å —ç–∫—Ä–∞–Ω –ø–æ ID
screen_instance_t* screen_get_by_id(const char *screen_id);

// –í–∏–¥–∏–º –ª–∏ —ç–∫—Ä–∞–Ω
bool screen_is_visible_check(const char *screen_id);

// –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤ –∏—Å—Ç–æ—Ä–∏–∏
uint8_t screen_get_history_count(void);

#ifdef __cplusplus
}
#endif
```

**–§–∞–π–ª:** `screen_manager/screen_manager.c`

```c
#include "screen_manager.h"
#include "esp_log.h"

static const char *TAG = "SCREEN_MANAGER";

/* =============================
 *  –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø
 * ============================= */

esp_err_t screen_manager_init(const screen_manager_config_t *config)
{
    ESP_LOGI(TAG, "Initializing Screen Manager");
    
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º —Ä–µ–µ—Å—Ç—Ä
    esp_err_t ret = screen_registry_init();
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to init registry: %s", esp_err_to_name(ret));
        return ret;
    }
    
    // –ü—Ä–∏–º–µ–Ω—è–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –µ—Å–ª–∏ –ø–µ—Ä–µ–¥–∞–Ω–∞
    if (config) {
        screen_manager_t *manager = screen_manager_get_instance();
        memcpy(&manager->config, config, sizeof(screen_manager_config_t));
    }
    
    ESP_LOGI(TAG, "Screen Manager initialized");
    return ESP_OK;
}

esp_err_t screen_manager_deinit(void)
{
    screen_manager_t *manager = screen_manager_get_instance();
    
    // –£–Ω–∏—á—Ç–æ–∂–∞–µ–º –≤—Å–µ —ç–∫–∑–µ–º–ø–ª—è—Ä—ã
    while (manager->instance_count > 0) {
        screen_instance_t *inst = manager->instances[0];
        if (inst && inst->config) {
            screen_destroy_instance(inst->config->id);
        }
    }
    
    // –û—Å–≤–æ–±–æ–∂–¥–∞–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
    for (int i = 0; i < manager->screen_count; i++) {
        if (manager->screens[i]) {
            free(manager->screens[i]);
        }
    }
    
    // –£–¥–∞–ª—è–µ–º –º—å—é—Ç–µ–∫—Å
    if (manager->mutex) {
        vSemaphoreDelete(manager->mutex);
    }
    
    memset(manager, 0, sizeof(screen_manager_t));
    
    ESP_LOGI(TAG, "Screen Manager deinitialized");
    return ESP_OK;
}

/* =============================
 *  –ù–ê–í–ò–ì–ê–¶–ò–Ø (Wrappers)
 * ============================= */

esp_err_t screen_show(const char *screen_id, void *params)
{
    return navigator_show(screen_id, params);
}

esp_err_t screen_hide(const char *screen_id)
{
    return screen_hide_instance(screen_id);
}

esp_err_t screen_go_back(void)
{
    return navigator_go_back();
}

esp_err_t screen_go_to_parent(void)
{
    return navigator_go_to_parent();
}

esp_err_t screen_go_home(void)
{
    return navigator_go_home();
}

esp_err_t screen_update(const char *screen_id, void *data)
{
    return screen_update_instance(screen_id, data);
}

/* =============================
 *  –£–ü–†–ê–í–õ–ï–ù–ò–ï
 * ============================= */

esp_err_t screen_create(const char *screen_id)
{
    return screen_create_instance(screen_id);
}

esp_err_t screen_destroy(const char *screen_id)
{
    return screen_destroy_instance(screen_id);
}

esp_err_t screen_reload(const char *screen_id)
{
    // –£–Ω–∏—á—Ç–æ–∂–∞–µ–º –∏ —Å–æ–∑–¥–∞–µ–º –∑–∞–Ω–æ–≤–æ
    esp_err_t ret = screen_destroy_instance(screen_id);
    if (ret != ESP_OK && ret != ESP_ERR_NOT_FOUND) {
        return ret;
    }
    
    return screen_create_instance(screen_id);
}

/* =============================
 *  –ì–ï–¢–¢–ï–†–´
 * ============================= */

screen_instance_t* screen_get_current(void)
{
    return screen_get_current_instance();
}

screen_instance_t* screen_get_by_id(const char *screen_id)
{
    return screen_get_instance_by_id(screen_id);
}

bool screen_is_visible_check(const char *screen_id)
{
    return screen_is_visible(screen_id);
}

uint8_t screen_get_history_count(void)
{
    return navigator_get_history_count();
}
```

**–ö—Ä–∏—Ç–µ—Ä–∏–π –ø—Ä–∏–µ–º–∫–∏:**
- ‚úÖ API –ø–æ–ª–Ω–æ—Å—Ç—å—é —Ä–∞–±–æ—Ç–∞–µ—Ç
- ‚úÖ –í—Å–µ —Ñ—É–Ω–∫—Ü–∏–∏ –ø—Ä–æ—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω—ã
- ‚úÖ –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è Doxygen

#### –ó–∞–¥–∞—á–∞ 4.2: –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏–æ–Ω–Ω—ã–µ —Ç–µ—Å—Ç—ã (4 —á–∞—Å–∞)

**–¢–µ—Å—Ç—ã –ø–æ–ª–Ω–æ–≥–æ —Ü–∏–∫–ª–∞:**
- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è ‚Üí –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è ‚Üí –ü–æ–∫–∞–∑ ‚Üí –ù–∞–≤–∏–≥–∞—Ü–∏—è ‚Üí –£–Ω–∏—á—Ç–æ–∂–µ–Ω–∏–µ

---

### –î–µ–Ω—å 5: –í–∏–¥–∂–µ—Ç—ã

#### –ó–∞–¥–∞—á–∞ 5.1: –ë–∞–∑–æ–≤—ã–µ –≤–∏–¥–∂–µ—Ç—ã (8 —á–∞—Å–æ–≤)

**–§–∞–π–ª:** `widgets/back_button.c`

```c
#include "lvgl.h"
#include "esp_log.h"

extern lv_style_t style_card;  // –ò–∑ lvgl_ui.c

lv_obj_t* widget_create_back_button(lv_obj_t *parent, 
                                     lv_event_cb_t callback,
                                     void *user_data)
{
    lv_obj_t *btn = lv_btn_create(parent);
    lv_obj_add_style(btn, &style_card, 0);
    lv_obj_set_size(btn, 60, 30);
    lv_obj_align(btn, LV_ALIGN_TOP_RIGHT, 0, 0);
    
    if (callback) {
        lv_obj_add_event_cb(btn, callback, LV_EVENT_CLICKED, user_data);
    }
    
    lv_obj_t *label = lv_label_create(btn);
    lv_label_set_text(label, LV_SYMBOL_LEFT);
    lv_obj_center(label);
    
    return btn;
}
```

**–§–∞–π–ª:** `widgets/status_bar.c`

```c
#include "lvgl.h"

extern lv_style_t style_card;
extern lv_style_t style_title;

lv_obj_t* widget_create_status_bar(lv_obj_t *parent, const char *title)
{
    lv_obj_t *bar = lv_obj_create(parent);
    lv_obj_add_style(bar, &style_card, 0);
    lv_obj_set_size(bar, LV_PCT(100), 60);
    lv_obj_align(bar, LV_ALIGN_TOP_MID, 0, 0);
    
    lv_obj_t *label = lv_label_create(bar);
    lv_obj_add_style(label, &style_title, 0);
    lv_label_set_text(label, title);
    lv_obj_center(label);
    
    return bar;
}
```

**–§–∞–π–ª:** `widgets/menu_list.c`

```c
#include "lvgl.h"

typedef struct {
    const char *text;
    const char *screen_id;
    lv_event_cb_t callback;
    void *user_data;
} menu_item_config_t;

lv_obj_t* widget_create_menu_list(lv_obj_t *parent,
                                   const menu_item_config_t *items,
                                   uint8_t item_count)
{
    lv_obj_t *list = lv_obj_create(parent);
    lv_obj_remove_style_all(list);
    lv_obj_set_size(list, LV_PCT(90), LV_PCT(70));
    lv_obj_align(list, LV_ALIGN_CENTER, 0, 20);
    lv_obj_set_flex_flow(list, LV_FLEX_FLOW_COLUMN);
    lv_obj_set_flex_align(list, LV_FLEX_ALIGN_START, 
                         LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER);
    lv_obj_set_style_pad_row(list, 8, 0);
    
    for (uint8_t i = 0; i < item_count; i++) {
        lv_obj_t *btn = lv_btn_create(list);
        lv_obj_set_size(btn, LV_PCT(100), 40);
        
        if (items[i].callback) {
            lv_obj_add_event_cb(btn, items[i].callback, 
                              LV_EVENT_CLICKED, items[i].user_data);
        }
        
        lv_obj_t *label = lv_label_create(btn);
        lv_label_set_text(label, items[i].text);
        lv_obj_center(label);
    }
    
    return list;
}
```

**–ö—Ä–∏—Ç–µ—Ä–∏–π –ø—Ä–∏–µ–º–∫–∏:**
- ‚úÖ 4+ –≤–∏–¥–∂–µ—Ç–∞ –≥–æ—Ç–æ–≤—ã
- ‚úÖ –ü–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–µ
- ‚úÖ –î–æ–∫—É–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω—ã

---

## üìÜ –ü—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ –ø–ª–∞–Ω–∞ –≤ —Å–ª–µ–¥—É—é—â–µ–π —á–∞—Å—Ç–∏...

–≠—Ç–æ –ø–µ—Ä–≤–∞—è –Ω–µ–¥–µ–ª—è –∏–∑ —Ç—Ä–µ—Ö. –ü–ª–∞–Ω –æ—á–µ–Ω—å –¥–µ—Ç–∞–ª—å–Ω—ã–π (–±—É–¥–µ—Ç ~200+ —Å—Ç—Ä–∞–Ω–∏—Ü –ø–æ–ª–Ω–æ—Å—Ç—å—é).

–•–æ—Ç–∏—Ç–µ —á—Ç–æ–±—ã —è:
1. –ü—Ä–æ–¥–æ–ª–∂–∏–ª —Å –ù–µ–¥–µ–ª–µ–π 2 –∏ 3?
2. –ò–ª–∏ —Å–Ω–∞—á–∞–ª–∞ –≤—ã —Ö–æ—Ç–∏—Ç–µ –æ–±—Å—É–¥–∏—Ç—å/—É—Ç–≤–µ—Ä–¥–∏—Ç—å –ù–µ–¥–µ–ª—é 1?
3. –ò–ª–∏ –Ω—É–∂–µ–Ω –±–æ–ª–µ–µ –∫—Ä–∞—Ç–∫–∏–π –≤–∞—Ä–∏–∞–Ω—Ç?

–¢–∞–∫–∂–µ –º–æ–≥—É —Å–æ–∑–¥–∞—Ç—å:
- –ß–µ–∫-–ª–∏—Å—Ç—ã –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –¥–Ω—è
- –®–∞–±–ª–æ–Ω—ã –∫–æ–¥–∞
- –î–∏–∞–≥—Ä–∞–º–º—ã Gantt
- –¢–∞–±–ª–∏—Ü—ã –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π –∑–∞–¥–∞—á

–ß—Ç–æ –ø—Ä–µ–¥–ø–æ—á—Ç–∏—Ç–µ–ª—å–Ω–µ–µ?

